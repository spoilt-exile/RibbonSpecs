<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Created on 6 серп 2013 16:34:49 -->

<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>
         Імпорт та експорт повідомлень
      </title>
      <meta name="GENERATOR" content="Arachnophilia 5.5"/>
      <meta name="FORMATTER" content="Arachnophilia 5.5"/>
      <link REL="stylesheet" type="text/css" href="../spec.css">
     	<meta charset="UTF-8" />
   </head>

<body>
<div class="main">
<div align="center" class="m-header">Імпорт та експорт повідомлень</div>
<br/>
<a href="_contents.html"><<<Назад</a>
<br/><br/>

<span class="strong">Версія API:</span> <span class="select">1</span><br/>

<br/>
<span class="header">Реалізація імпорту/експорту у системі</span><br/>
<br/>
"Стрічка" підтримує просту модульну архітектуру для модулів імпорту і експорту для 
комунікації системи з зовнішньою інформацією. Ця особливість системи дозволяє її 
взаємодіяти з багатьма протоколами та іншими засобами передачі інформаційних повідомлень.<br/>
<br/>
Система імпорта/експорта (або система вводу/виводу) реалізується окремою бібліотекою libRibbonIO. Ця бібліотека 
містить як класи та об’єкти необхідні для імпорту, так і для експорту повідомлень. Також ця бібліотека надає 
базовий інтерфейс для модулів і завантажує їх під час запуску системи.<br/>
<br/>
Кожен модуль є окремим виконавчим файлом jar, який виконує одну окрему операцію імпорту чи експорту. Взагалі 
нічого не перешкоджає створити один модуль який містить багато операцій імпорту і експорту одночасно.<br/>
<br/>

<span class="header">Імпорт повідомлень до системи</span><br/>
<br/>

Імпорт повідомлень алгоритмічно виглядає так: перевірка на предмет нових даних -> отримання та випуск даних -> 
позначення останньої позиції або вилучення усіх випущених даних (щоб не випустити їх ще раз) -> перерва.<br/>
<br/>

Модуль іморту успадковує клас <span class="code-text">Import.Importer</span> з бібліотеки libRibbonIO. Це окремий потік, 
який за встановленою перервою виконує метод імпорту <span class="code-text">doImport()</span>. Цей метод читає дані 
з джерела модуля, випускає ці дані за напрямком і позначує останнє повідомлення.<br/>
<br/>

У разі якщо модуль не може зчитати, чи випустити дані, то сервер системи переходить у "брудний" режим. Це означає 
що потоки даних у системі втратили цілісність. Для виходу з цього стану модуль ще реалізує два службових методи: 
<span class="code-text">tryRecover()</span> і <span class="code-text">resetState()</span>. Перший метод 
запускає спробу виправити накопичені помилки модулю. Другий метод переводить модуль і систему до нормального режиму. 
Ці методи не обов’язкові для реалізація, але дуже бажані.<br/>
<br/>

Клас модулю повинен, окрім успадкування класу <span class="code-text">Import.Importer</span>, містити 
анотацію <span class="code-text">Utils.RibbonIOModule</span>, яка повідомляє системі, що це є клас модуля. 
Дана анотація містить у собі три параметра: <span class="code-text">type</span> (тип модулю), 
<span class="code-text">property</span> (ідентифікатор для системних ознак) та 
api_<span class="code-text">version</span> (версія API яка потребуэться для запуску модуля).<br/>
<br/>

Приклад використання анотації:
<pre class="code-frame">
<span class="red-text">@RibbonIOModule(type="MAIL", property="EXPORT_MAIL", api_version=1)</span>
public class Mail extends Export.Exporter {
</pre>

Слід зауважити, що система перевіряє при завантаженні версію API і намагається не завантажувати модулі 
з більш новим API ніж у системі.<br/>
<br/>

Модуль компілюється у окремий виконавчий файл jar і не містить жодних налаштувань. Сервер створює екземпляри 
модулів за потребою при наявності відповідної до типу модулю схеми імпорту. Схеми імпорту це окремі файли типу 
<span class="green-text">*.import</span>, які зберігаються у окремій теці <span class="green-text">import</span>, 
що знаходиться у базі повідомлень. Схеми за форматом ідентичні до файлів properties, за винятком того, що 
у схемах зустрічається UTF-8. Параметри схеми поділяються на загальні та модуль-специфічні. Загальні параметри 
обробляються самим класом <span class="code-text">Import.Importer</span>, тоді як специфічні впливають лише 
на переписані методи модулю.<br/>

<br/>
Загальні параметри схеми імпорту (<span class="code-text"><span class="red-text">[!]</span></span> - обов’язковий параметр):<br/>
<ul>
  <li><span class="code-text">import_type <span class="green-text">[Рядок]</span> <span class="red-text">[!]</span></span> - 
  тип необхідного модулю для роботи цієї схеми;</li>
  <li><span class="code-text">import_name <span class="green-text">[Рядок]</span> <span class="red-text">[!]</span></span> - 
  ім’я схеми під яким вона буде діяти у системі;</li>
  <li><span class="code-text">import_print <span class="green-text">[Хеш]</span></span> - 
  системний ідентифікатор схеми у системі (автоматично створюється разом зі схемою);</li>
  <li><span class="code-text">import_timeout <span class="green-text">[Ціле]</span> <span class="red-text">[!]</span></span> - 
  тривалість перерви між перевірками на предмет нових даних (у хвилинах);</li>
  <li><span class="code-text">opt_log <span class="green-text">[Булеве]</span></span> - 
  заносити запис у системний журнал при вдалому випуску;</li>
</ul>

Приклад схеми без специфічних параметрів:<br/>

<pre class="code-frame">
import_type=PLAIN
import_name=TEST
import_print=033bd94b1168d7e4f0d644c3c95e35bf
import_timeout=1
...
opt_log=1
</pre>

При завантаженні сервер спочатку завантажує класи модулів з окремої теки <span class="green-text">imports</span> поряд 
з виконавчим файлом сервера системи. При завантаженні класу, сервер повинен визначити клас за допомогою змінної 
<span class="code-text">type</span> і зареєструвати системну ознаку модуля, взявши значення <span class="code-text">propertyType</span>. 
Після завантаження класів, сервер завантажує схеми імпорту і намагається підібрати відповідний модуль до схеми. 
Якщо відповідного модулю немає, сервер не буде завантажувати схему. При цьому кількість екземплярів одного й того ж модулю 
не обмежена. Після знаходження модулю, сервер створює екземпляр класу модулю з налаштуваннями схеми і додає цей екземпляр до 
черги імпорту. Після остаточного завантаження, сервер запускає усі екземпляри (на кожний екземпляр - окремий потік).<br/>
<br/>

<span class="header">Експорт повідомлень з системи</span><br/>
<br/>

Експорт повідомлень алгоритмічно виглядає складніше: випуск повідомлення до напрямків -> перевірка чи налаштований напрямок на експорт 
-> запуск експорту -> перерва (якщо є) -> виконання експорту.<br/>
<br/>

Модуль експорту успадковує клас <span class="code-text">Export.Exporter</span> з бібліотеки libRibbonIO. Аналогічно до імпорту цей клас містить метод 
<span class="code-text">doExport()</span>, який виконує експорт повідомлення з системи. 
Анотація <span class="code-text">RibbonIOModule</span> також є обов’язковою.<br/>
<br/>

Також є методи <span class="code-text">tryRecover()</span>, який служить для відновлення експорту повідомлення після 
після отримання помилки, Якщо повідомлення попадає до аварійної черги, то потік аварійного випуску буде викликати саме 
цей метод. Цей метод реалізовано у класі <span class="code-text">Export.Exporter</span> і може бути переписаний.<br/>
<br/>

Як і у справі з імпортом, модуль експорту компілюється у окремий jar файл і не містить налаштувань. Готові модулі розташовуються у окремій теці пакету 
сервера <span class="green-text">exports</span> поряд з виконавчим файлом сервера системи. Схеми експорту мають схожу структуру, але зберігаються окремо 
у теці <span class="green-text">export</span>, що знаходиться у базі повідомлень.<br/>
<br/>

Загальні параметри схеми експорту (<span class="code-text"><span class="red-text">[!]</span></span> - обов’язковий параметр):
<ul>
  <li><span class="code-text">export_type <span class="green-text">[Рядок]</span> <span class="red-text">[!]</span></span> - 
  тип необхідного модулю для роботи цієї схеми;</li>
  <li><span class="code-text">export_name <span class="green-text">[Рядок]</span> <span class="red-text">[!]</span></span> - 
  ім’я схеми під яким вона буде діяти у системі;</li>
  <li><span class="code-text">export_print <span class="green-text">[Хеш]</span></span> - 
  системний ідентифікатор схеми у системі (автоматично створюється разом зі схемою);</li>
  <li><span class="code-text">export_template <span class="green-text">[Рядок]</span></span> - 
  шлях до файлу шаблону за яким формується текст повідомлення при експорті 
  (<span class="select">див. нижче</span>);</li>
  <li><span class="code-text">opt_log <span class="green-text">[Булеве]</span></span> - 
  заносити запис у системний журнал при вдалому випуску;</li>
  <li><span class="code-text">opt_charset <span class="green-text">[Рядок]</span></span> - 
  встановлює кодову сторінку для експорту. Зауваження: модуль може ігнорувати цей параметр;</li>
  <li><span class="code-text">opt_em_action <span class="green-text">[Перечислення]</span></span> - 
  встановлює поведінку системи у разі отримання помилки експорту. Значення: <span class="code-text">PLACE_ERRQ_DIRTY </span>
  (додає повідомлення у аварійну чергу і встановлює "брудний режим"), <span class="code-text">DROP_WARN </span>
  (викинути повідомлення з експорту і вислати помилку) і <span class="code-text">DROP_SILENT</span> (тихо викинути). 
  За замовчуванням використовується значення <span class="code-text">PLACE_ERRQ_DIRTY</span>;</li>
</ul>

Приклад схеми без специфічних параметрів:<br/>

<pre class="code-frame">
export_type=PLAIN
export_name=HTML
export_print=4f0d644c3c95e35bf033bd94b1168d7e
export_template=HTML.template
...
opt_charset=Cp1251
opt_em_action=DROP_SILENT
opt_log=1
</pre>


Внутрішня реалізація експорту дещо відрізняється від імпорту повідомлень. На початку запуску сервер 
завантажує класи модулів і потім створює екземпляри класу <span class="code-text">Export.Schema</span>, 
який виконує роль фабрики екземплярів класу <span class="code-text">Export.Exporter</span> та успадкованих модулем класів. 
Далі система починає завантажувати напрямки та перевіряти листи експорту кожного напрямку. Якщо у листі експорту 
напрямку вказано діячу схему експорту, то сервер оформляє підписку на цю схему.<br/>
<br/>
Під час випуску повідомлення сервер перевіряє за листом підписок, чи потрібно поточне повідомлення експортувати з системи. 
Якщо сервер знаходить схеми експорту за напрямками повідомлення, то він ініціює процес експорту. 
При цьому повідомлення, які позначені системною ознакою <span class="code-text">PROCESSING_FORBIDDEN</span>, 
ігноруються системою. На кожну отриману схему 
сервер створює новий екземпляр класу модулю і передає йому повідомлення. Для мінімізації операцій з індексами бази 
повідомлень сервер кожний схемі експорту передає об’єкт "гачка" (екземпляр <span class="code-text">Export.ReleaseSwitch</span>) 
який оновить системні ознаки повідомлення у базі тільки коли буде завершено експорт повідомлення за усіма схемами. Після 
експорту і оновлення даних, екземпляри усіх заподіяних об’єктив знищуються.<br/>
<br/>

<span class="header">Формат повідомлення при експорті</span><br/>
<br/>

При експорті повідомлення система здатна відформатувати текст повідомлення згідно з шаблоном. Це гарантує єдиний вигляд 
усіх повідомлень на виході. Щоб схема використовувала шаблон, потрібно вказати шлях до файлу шаблону у параметрі 
<span class="code-text">export_template</span>. Без шаблону сервер буде експортувати зміст змінної 
<span class="code-text">Message.CONTENT</span> без обробки.<br/>
<br/>
Файл шаблону має форму *.template і за форматом є простим текстовим файлом з ключовими словами. Спеціальній 
об’єкт-форматер (екземпляр класу <span class="code-text">Export.Formatter</span>) переносить весь зміст шаблону, 
заміняючи ключові слова відповідними даними. Потим форматований текст експортується.<br/>
<br/>
Усі ключові слова починаються з символу <span class="code-text">$</span> і не можуть містити пробілів. Знайшовши цей символ 
форматер бере слово після цього символу і шукає його серед листа ключових слів. З точки зору форматера, кожне ключове слово 
є екземпляром приватного класу <span class="code-text">Export.Formatter.FormatOperation</span>. Цей клас відповідає за обробку 
власного ключового слова і містить метод <span class="code-text">process()</span>, який обробляє слово і повертає 
форматований рядок. Об’єкт-форматер містить цілий масив таких екземплярів і опрацьовує повідомлення згідно з ними.<br/>
<br/>

Простий приклад шаблону:
<pre class="code-frame">
Це повідомлення випущено $DATE
</pre>

При обробці за цим шаблоном сервер експортує повідомлення з таким змістом:
<pre class="code-frame">
Це повідомлення випущено <span class="red-text">16:34:28 04.08.2013</span>
</pre>

Об’єкт-форматер переносить зміст шаблону символ за символом, тому у остаточний текст будуть переноситись навіть керуючи 
символи і інші.<br/>
<br/>

Лист ключових слів які підтримуються:
<ul>
  <li><span class="code-text">INDEX</span> - індекс повідомлення у системі (без обробки);</li>
  <li><span class="code-text">DIR</span> - напрямок за яким експортовано повідомлення (без обробки);</li>
  <li><span class="code-text">TAGS</span> - теги повідомлення у вигляді 
  <span class="select">"тег1, тег2, тег3"</span> (вимагає обробки);</li>
  <li><span class="code-text">DEFIS_TAGS</span> - теги повідомлення у вигляді
  <span class="select">ТЕГ1-ТЕГ2-ТЕГ3</span> (вимагає обробки);</li>
  <li><span class="code-text">HEADER</span> - заголовок повідомлення (без обробки);</li>
  <li><span class="code-text">UPPER_HEADER</span> - капіталізований заголовок (з обробкою);</li>
  <li><span class="code-text">CONTENT</span> - зміст повідомлення (без обробки);</li>
  <li><span class="code-text">HTML_CONTENT</span> зміст повідомлення для експорту в 
  HTML, усі символи переходу рядку замінено на відповідний тег (вимагає обробки);</li>
  <li><span class="code-text">AUTHOR</span> - автор повідомлення, якому належать авторські права (без обробки);</li>
  <li><span class="code-text">DATE</span> - дата випуску (без обробки);</li>
</ul>

Приклад складного шаблону:
<pre class="code-frame">
Тестовий експорт повідомлень (схема ТЕСТ)

Напрямок: <span class="red-text">$DIR</span>
Номер у базі: <span class="red-text">$INDEX</span>

<span class="red-text">$DEFIS_TAGS</span>
<span class="red-text">$HEADER</span>

<span class="red-text">$CONTENT</span>

Автор <span class="red-text">$AUTHOR  $DATE</span> 
</pre>

Зміст повідомлення після форматування (червоним помічено те що оброблено за ключьовими словами):
<pre class="code-frame">
Тестовий експорт повідомлень (схема ТЕСТ)

Напрямок: <span class="red-text">Експорт.PLAIN</span>
Номер у базі: <span class="red-text">0000002062</span>

<span class="red-text">ПУТІН-ОБАМА-СНОУДЕН-ЗУСТРІЧ-СКАСУВАННЯ</span>
<span class="red-text">Обама скасував зустріч з Путіним через Сноудена</span>

<span class="red-text">Президент США Барак Обама в середу скасував свій візит до Москви для зустрічі з президентом Росії Володимиром Путіним.

Про це у середу 7 серпня повідомляє Associated Press.

За інформацією АР, Обама все ж відвідає економічний саміт G20 у Санкт-Петербурзі, але у Білому домі поінформували, 
що від переговорів один на один у Москві президент США утримається.

Замість зустрічі з Путіним, на початку вересня Обама відвідає Швецію.

За словами заступника радника з національної безпеки Білого дому Бена Родса, рішення Росії щодо надання Сноудену 
тимчасового притулку тільки посилило і без того складні відносини країн.

Як повідомляв Укрінформ, 1 серпня Едвард Сноуден залишив транзитну зону московського аеропорту Шереметьєво, в якій він 
знаходився з 23 червня.

Сноуден - колишній співробітник спецслужб США, який оприлюднив секрети західноєвропейських і американських розвідок.

Влада США пред'явила Сноудену звинувачення за трьома статтями, за кожною з яких йому загрожує до 10 років ув'язнення. 
Він звинувачується в незаконній передачі інформації, що має значення для національної безпеки, умисній передачі 
розвідувальної інформації і крадіжці власності держави.</span>


Автор <span class="red-text">Непочатов С.І.  17:08:44 07.08.2013 </span>
</pre><br/>


<span class="header">Cистемна обгортка</span><br/>
<br/>
Для комунікації з сервером системи модулі вводу/виводу повіні використовувати так звану системну обгортку. Ця обгортка 
містить методи, які може використовувати модуль для зв’язку з системою.<br/>
<br/>
Обгортка реалізована як обстрактний клас з абстрактними методами. Сервер на своєї стороні реалізує цей клас з усіма методами. 
Потім екземпляр цього класу реєструється у підсистемі вводу/виводу як обгортка по замовчуванню. Після цього усі модулі можуть 
використовувати ці методи прямим викликом.

<br/>
<br/>
Далі іде список методів:<br/>

<ul>
  <li><span class="code-text">public void addMessage(String schemeName, String typeName, MessageClasses.Message givenMessage)</span>
   - додати готове повідомлення до системи. Вимогає надати назву схеми, тип модулю і повідомлення. 
   Використовується для імпорту до системи.</li>
   <li><span class="code-text">public void enableDirtyState(String moduleType, String moduleScheme, String modulePrint)</span> 
   - увімкнути "брудний" режим системи після збою модулю. Про цьому модуль повинен надати свій тип, назву схеми і свій ідентифікатор. 
   Модулі експорту для коректної ідентифікації повіні надавати ідентифікатор спарений з індексом повідомлення.</li>
   <li><span class="code-text">public void disableDirtyState(String moduleType, String moduleScheme, String modulePrint)</span> 
   - вимнути "брудний" режим системи після відновлення роботи модуля. Якщо ще якісь модулі вмикали цей режим, то повне відновлення 
   роботи системи може не статися. Кожний модуль, який вмикав "брудний" режим, повинен самостійного його вимкнути.</li>
   <li><span class="code-text">public String getDate()</span> 
   - повертає рядок поточної дати за форматом "ГГ:ХХ:СС ДД.ММ.РРРР".</li>
   <li><span class="code-text">public String getProperty(String key)</span> 
   - метод для отримання конфігурації системи з головного файлу конфігурації. Повертає значення за ключьом.</li>
   <li><span class="code-text">public void postException(String desc, Throwable ex)</span> 
   - випустити виключення як повідомлення до системи. Вимогає надати невеликий опис події і сам об’єкт виключення.</li>
   <li><span class="code-text">public void registerPropertyName(String givenName)</span> 
   - зареєструвати тип озники у системі. Вимагає вказати тип ознаки.</li>
   <li><span class="code-text">public void updateIndex(String givenIndex)</span> 
   - оновити індекс повідомлення у системі і сповістити усіх клієнтів. Вимагає наадати індекс повідомлення. 
   Використовується для оновлення повідомлення після експорту.</li>
</ul>

</div>
</body>
</html>
