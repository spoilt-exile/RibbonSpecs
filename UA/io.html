<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Created on 6 серп 2013 16:34:49 -->

<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>
         Імпорт та експорт повідомлень
      </title>
      <meta name="GENERATOR" content="Arachnophilia 5.5"/>
      <meta name="FORMATTER" content="Arachnophilia 5.5"/>
      <link REL="stylesheet" type="text/css" href="../spec.css">
   </head>

<body>
<div align="center" class="m-header">Імпорт та експорт повідомлень</div>
<br/>
<a href="_contents.html"><<<Назад</a>
<br/>
<br/>
<div class="main">
<span class="header">Реалізація імпорту/експорту у системі</span><br/>
<br/>
"Стрічка" підтримує просту модульну архітектуру для модулів імпорту і експорту для 
комунікації системи з зовнішньою інформацією. Ця особливість системи дозволяє її 
взаємодіяти з багатьма протоколами та іншими засобами передачі інформаційних повідомлень.<br/>
<br/>
Система імпорта/експорта (або система вводу/виводу) реалізується окремою бібліотекою libRibbonIO. Ця бібліотека 
містить як класи та об’єкти необхідні для імпорту, так і для експорту повідомлень. Також ця бібліотека надає 
базовий інтерфейс для модулів і завантажує їх під час запуску системи.<br/>
<br/>
Кожен модуль є окремим виконавчим файлом jar, який виконує одну окрему операцію імпорту чи експорту. Взагалі 
нічого не перешкоджає створити один модуль який містить багато операцій імпорту і експорту одночасно.<br/>
<br/>


<span class="header">Імпорт повідомлень до системи</span><br/>
<br/>

Імпорт повідомлень алгоритмічно виглядає так: перевірка на предмет нових даних -> отримання та випуск даних -> 
позначення останньої позиції або вилучення усіх випущених даних (щоб не випустити їх ще раз) -> перерва.<br/>
<br/>

Модуль іморту успадковує клас <span class="code-text">Import.Importer</span> з бібліотеки libRibbonIO. Це окремий потік, 
який за встановленою перервою виконує метод імпорту <span class="code-text">doImport()</span>. Цей метод читає дані 
з джерела модуля, випускає ці дані за напрямком і позначує останнє повідомлення.<br/>
<br/>

У разі якщо модуль не може зчитати, чи випустити дані, то сервер системи переходить у "брудний" режим. Це означає 
що потоки даних у системі втратили цілісність. Для виходу з цього стану модуль ще реалізує два службових методи: 
<span class="code-text">tryRecover()</span> і <span class="code-text">resetState()</span>. Перший метод 
запускає спробу виправити накопичені помилки модулю. Другий метод переводить модуль і систему до нормального режиму. 
Ці методи не обов’язкові для реалізація, але дуже бажані.<br/>
<br/>

Клас модулю повинен, окрім успадкування класу <span class="code-text">Import.Importer</span>, містити змінні типу 
<span class="code-text"><span class="green-text">String</span></span> 
<span class="code-text">type</span> і <span class="code-text">propertyType</span>, які мають бути 
статичними та публічними одночасно (<span class="code-text">public static</span>). Перша змінна 
дозволяє визначити тип модулю - з яким протоколом він взаємодіє. Друга змінна - це ідентифікатор 
системної ознаки, якою мають бути помічені усі повідомлення оброблені цим модулем.<br/>
<br/>

Модуль компілюється у окремий виконавчий файл jar і не містить жодних налаштувань. Сервер створює екземпляри 
модулів за потребою при наявності відповідної до типу модулю схеми імпорту. Схеми імпорту це окремі файли типу 
<span class="green-text">*.import</span>, які зберігаються у окремій теці <span class="green-text">import</span>, 
що знаходиться у базі повідомлень. Схеми за форматом ідентичні до файлів properties, за винятком того, що 
у схемах зустрічається UTF-8. Параметри схеми поділяються на загальні та модуль-специфічні. Загальні параметри 
обробляються самим класом <span class="code-text">Import.Importer</span>, тоді як специфічні впливають лише 
на переписані методи модулю.<br/>

<br/>
Загальні параметри схеми імпорту:<br/>
<ul>
  <li><span class="code-text">import_type <span class="green-text">[Рядок]</span></span> - 
  тип необхідного модулю для роботи цієї схеми;</li>
  <li><span class="code-text">import_name <span class="green-text">[Рядок]</span></span> - 
  ім’я схеми під яким вона буде діяти у системі;</li>
  <li><span class="code-text">import_print <span class="green-text">[Хеш]</span></span> - 
  системний ідентифікатор схеми у системі (автоматично створюється разом зі схемою);</li>
  <li><span class="code-text">import_timeout <span class="green-text">[Ціле]</span></span> - 
  тривалість перерви між перевірками на предмет нових даних (у хвилинах);</li>
  <li><span class="code-text">opt_log <span class="green-text">[Булеве]</span></span> - 
  заносити запис у системний журнал при вдалому випуску;</li>
</ul>

Приклад схеми без специфічних параметрів:<br/>

<pre class="code-frame">
import_type=PLAIN
import_name=TEST
import_print=033bd94b1168d7e4f0d644c3c95e35bf
import_timeout=1
...
opt_log=1
</pre>

При завантаженні сервер спочатку завантажує класи модулів з окремої теки <span class="green-text">imports</span> поряд 
з виконавчим файлом сервера системи. При завантаженні класу, сервер повинен визначити клас за допомогою змінної 
<span class="code-text">type</span> і зареєструвати системну ознаку модуля, взявши значення <span class="code-text">propertyType</span>. 
Після завантаження класів, сервер завантажує схеми імпорту і намагається підібрати відповідний модуль до схеми. 
Якщо відповідного модулю немає, сервер не буде завантажувати схему. При цьому кількість екземплярів одного й того ж модулю 
не обмежена. Після знаходження модулю, сервер створює екземпляр класу модулю з налаштуваннями схеми і додає цей екземпляр до 
черги імпорту. Після остаточного завантаження, сервер запускає усі екземпляри (на кожний екземпляр - окремий потік).<br/>
<br/>

<span class="header">Експорт повідомлень з системи</span><br/>
<br/>

Експорт повідомлень алгоритмічно виглядає складніше: випуск повідомлення до напрямків -> перевірка чи налаштований напрямок на експорт 
-> запуск експорту -> перерва (якщо є) -> виконання експорту.<br/>
<br/>

Модуль експорту успадковує клас <span class="code-text">Export.Exporter</span> з бібліотеки libRibbonIO. Аналогічно до імпорту цей клас містить метод 
<span class="code-text">doExport()</span>, який виконує експорт повідомлення з системи. Статичні змінні <span class="code-text">type</span> і 
<span class="code-text">propertyType</span> також обов’язкові для модуля.<br/>
<br/>

Також є методи <span class="code-text">tryRecover()</span> і <span class="code-text">resetState()</span>, які створені для виправлення роботи 
модуля експорту у випадку помилки. Але поточна реалізація libRibbonIO не використовує ці методи.<br/>
<br/>

Як і у справі з імпортом, модуль експорту компілюється у окремий jar файл і не містить налаштувань. Готові модулі розташовуються у теці 
<span class="green-text">exports</span> поряд з виконавчим файлом сервера системи. Схеми експорту мають схожу структуру, але зберігаються окремо 
у теці <span class="green-text">export</span>, що знаходиться у базі повідомлень.<br/>
<br/>

Загальні параметри схеми експорту:
<ul>
  <li><span class="code-text">export_type <span class="green-text">[Рядок]</span></span> - 
  тип необхідного модулю для роботи цієї схеми;</li>
  <li><span class="code-text">export_name <span class="green-text">[Рядок]</span></span> - 
  ім’я схеми під яким вона буде діяти у системі;</li>
  <li><span class="code-text">export_print <span class="green-text">[Хеш]</span></span> - 
  системний ідентифікатор схеми у системі (автоматично створюється разом зі схемою);</li>
  <li><span class="code-text">export_timeout <span class="green-text">[Ціле]</span></span> - 
  тривалість перерви перед самим процесом експорту;</li>
  <li><span class="code-text">export_template <span class="green-text">[Рядок]</span></span> - 
  шлях до файлу шаблону за яким формується текст повідомлення при експорті 
  (<span class="select">див. нижче</span>);</li>
  <li><span class="code-text">opt_log <span class="green-text">[Булеве]</span></span> - 
  заносити запис у системний журнал при вдалому випуску;</li>
</ul>

Приклад схеми без специфічних параметрів:<br/>

<pre class="code-frame">
export_type=PLAIN
export_name=HTML
export_print=4f0d644c3c95e35bf033bd94b1168d7e
export_timeout=1
export_template=/home/spoilt/РАБОТА [УКРИНФОРМ]/ribbon_base/export/HTML.template
...
opt_log=1
</pre>


Внутрішня реалізація експорту дещо відрізняється від імпорту повідомлень. На початку запуску сервер 
завантажує класи модулів і потім створює екземпляри класу <span class="code-text">Export.Schema</span>, 
який виконує роль фабрики екземплярів класу <span class="code-text">Export.Exporter</span> та успадкованих модулем класів. 
Далі система починає завантажувати напрямки та перевіряти листи експорту кожного напрямку. Якщо у листі експорту 
напрямку вказано діячу схему експорту, то сервер оформляє підписку на цю схему.<br/>
<br/>
Під час випуску повідомлення сервер перевіряє за листом підписок, чи потрібно поточне повідомлення експортувати з системи. 
Якщо сервер знаходить схеми експорту за напрямками повідомлення, то він ініціює процес експорту. На кожну отриману схему 
сервер створює новий екземпляр класу модулю і передає йому повідомлення. Для мінімізації операцій з індексами бази 
повідомлень сервер кожний схемі експорту передає об’єкт "гачка" (екземпляр <span class="code-text">Export.ReleaseSwitch</span>) 
який оновить системні ознаки повідомлення у базі тільки коли буде завершено експорт повідомлення за усіма схемами. Після 
експорту і оновлення даних, екземпляри усіх заподіяних об’єктив знищуються.<br/>
<br/>

<span class="red-text">
Поточна реалізація бібліотеки libRibbonIO не підтримує обробку помилок експорту і відновлення після помилки. Також 
не реалізована затримка перед експортом і заборона експорту повідомлення якщо воно помічене ознакою 
<span class="code-text">PROCESSING_FORBIDDEN</span>.</span>
<br/>
<br/>

<span class="header">Формат повідомлення при експорті</span><br/>
<br/>

При експорті повідомлення система здатна відформатувати текст повідомлення згідно з шаблоном. Це гарантує єдиний вигляд 
усіх повідомлень на виході. Щоб схема використовувала шаблон, потрібно вказати шлях до файлу шаблону у параметрі 
<span class="code-text">export_template</span>. Без шаблону сервер буде експортувати зміст змінної 
<span class="code-text">Message.CONTENT</span> без обробки.<br/>
<br/>
Файл шаблону має форму *.template і за форматом є простим текстовим файлом з ключовими словами. Спеціальній 
об’єкт-форматер (екземпляр класу <span class="code-text">Export.Formatter</span>) переносить весь зміст шаблону, 
заміняючи ключові слова відповідними даними. Потим форматований текст експортується.<br/>
<br/>
Усі ключові слова починаються з символу <span class="code-text">$</span> і не можуть містити пробілів. Знайшовши цей символ 
форматер бере слово після цього символу і шукає його серед листа ключових слів. З точки зору форматера, кожне ключове слово 
є екземпляром приватного класу <span class="code-text">Export.Formatter.FormatOperation</span>. Цей клас відповідає за обробку 
власного ключового слова і містить метод <span class="code-text">process()</span>, який обробляє слово і повертає 
форматований рядок. Об’єкт-форматер містить цілий масив таких екземплярів і опрацьовує повідомлення згідно з ними.<br/>
<br/>

Простий приклад шаблону:
<pre class="code-frame">
Це повідомлення випущено $DATE
</pre>

При обробці за цим шаблоном сервер експортує повідомлення з таким змістом:
<pre class="code-frame">
Це повідомлення випущено <span class="red-text">16:34:28 04.08.2013</span>
</pre>

Об’єкт-форматер переносить зміст шаблону символ за символом, тому у остаточний текст будуть переноситись навіть керуючи 
символи і інші.<br/>
<br/>

Лист ключових слів які підтримуються:
<ul>
  <li><span class="code-text">INDEX</span> - індекс повідомлення у системі (без обробки);</li>
  <li><span class="code-text">DIR</span> - напрямок за яким експортовано повідомлення (без обробки);</li>
  <li><span class="code-text">TAGS</span> - теги повідомлення у вигляді 
  <span class="select">"тег1, тег2, тег3"</span> (вимагає обробки);</li>
  <li><span class="code-text">DEFIS_TAGS</span> - теги повідомлення у вигляді
  <span class="select">ТЕГ1-ТЕГ2-ТЕГ3</span> (вимагає обробки);</li>
  <li><span class="code-text">HEADER</span> - заголовок повідомлення (без обробки);</li>
  <li><span class="code-text">UPPER_HEADER</span> - капіталізований заголовок (з обробкою);</li>
  <li><span class="code-text">CONTENT</span> - зміст повідомлення (без обробки);</li>
  <li><span class="code-text">HTML_CONTENT</span> зміст повідомлення для експорту в 
  HTML, усі символи переходу рядку замінено на відповідний тег (вимагає обробки);</li>
  <li><span class="code-text">AUTHOR</span> - автор повідомлення, якому належать авторські права (без обробки);</li>
  <li><span class="code-text">DATE</span> - дата випуску (без обробки);</li>
</ul>

Приклад складного шаблону:
<pre class="code-frame">
Тестовий експорт повідомлень (схема ТЕСТ)

Напрямок: <span class="red-text">$DIR</span>
Номер у базі: <span class="red-text">$INDEX</span>

<span class="red-text">$DEFIS_TAGS</span>
<span class="red-text">$HEADER</span>

<span class="red-text">$CONTENT</span>

Автор <span class="red-text">$AUTHOR  $DATE</span> 
</pre>

Зміст повідомлення після форматування (червоним помічено те що оброблено за ключьовими словами):
<pre class="code-frame">
Тестовий експорт повідомлень (схема ТЕСТ)

Напрямок: <span class="red-text">Експорт.PLAIN</span>
Номер у базі: <span class="red-text">0000002062</span>

<span class="red-text">ПУТІН-ОБАМА-СНОУДЕН-ЗУСТРІЧ-СКАСУВАННЯ</span>
<span class="red-text">Обама скасував зустріч з Путіним через Сноудена</span>

<span class="red-text">Президент США Барак Обама в середу скасував свій візит до Москви для зустрічі з президентом Росії Володимиром Путіним.

Про це у середу 7 серпня повідомляє Associated Press.

За інформацією АР, Обама все ж відвідає економічний саміт G20 у Санкт-Петербурзі, але у Білому домі поінформували, 
що від переговорів один на один у Москві президент США утримається.

Замість зустрічі з Путіним, на початку вересня Обама відвідає Швецію.

За словами заступника радника з національної безпеки Білого дому Бена Родса, рішення Росії щодо надання Сноудену 
тимчасового притулку тільки посилило і без того складні відносини країн.

Як повідомляв Укрінформ, 1 серпня Едвард Сноуден залишив транзитну зону московського аеропорту Шереметьєво, в якій він 
знаходився з 23 червня.

Сноуден - колишній співробітник спецслужб США, який оприлюднив секрети західноєвропейських і американських розвідок.

Влада США пред'явила Сноудену звинувачення за трьома статтями, за кожною з яких йому загрожує до 10 років ув'язнення. 
Він звинувачується в незаконній передачі інформації, що має значення для національної безпеки, умисній передачі 
розвідувальної інформації і крадіжці власності держави.</span>


Автор <span class="red-text">Непочатов С.І.  17:08:44 07.08.2013 </span>
</pre>

</div>
</body>
</html>
